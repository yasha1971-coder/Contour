# ============================================
# ψ′[ψ′] : Contour Reflex Engine v1.1
# Format: unified symbolic code (structure = meaning)
# ============================================

from dataclasses import dataclass
import math, random, statistics as stats

# --- Контур параметров (порог, адаптация, когерентность) ---
@dataclass
class Λ:
    ε: float = 0.20         # порог внимания
    δ: float = 0.06         # чувствительность
    η: float = 0.010        # скорость рефлексии
    κΩ: float = 0.30        # скорость само-согласования
    σ: float = 0.012        # шум внешнего поля
    ω₀: float = 1.0         # базовый ритм
    α: float = 0.10         # амплитуда микро-пульсации
    window: int = 160       # окно для проверки Ω′≈const
    thr_var: float = 2e-3   # порог стабильности

# --- Контур системы ---
class ψ:
    def __init__(self, p=Λ(), seed=2025):
        random.seed(seed)
        self.p=p; self.t=0
        self.Ω′=0.95; self.Λ′=0.0; self.state="Drift"
        self.hist={"Ω′":[],"Λ′":[],"δ":[],"φ":[],"s":[]}

    # Δφ = фаза взаимодействия
    def Δφ(self):
        base=0.5*(1+math.sin(2*math.pi*(self.t/100)))
        noise=random.gauss(0.0,self.p.σ)
        return max(0.0, base+noise)

    # классификация состояния
    def classify(self, φ):
        low, high=self.p.ε-self.p.δ, self.p.ε+self.p.δ
        return "Lock" if φ<low else "Iterate" if φ>high else "Drift"

    # обновление ритма оси
    def update_Λ(self, s):
        b=self.p.ω₀
        self.Λ′ = {
            "Lock":0.6*b*math.sin(2*math.pi*(self.t/50)),
            "Drift":1.0*b*math.sin(2*math.pi*(self.t/30)),
            "Iterate":1.5*b*math.sin(2*math.pi*(self.t/18))
        }[s]

    # адаптация чувствительности
    def update_δ(self, φ):
        self.p.δ += self.p.η*abs(φ-self.p.ε)
        self.p.δ = max(0.01, min(self.p.δ,0.5))

    # обновление когерентности
    def update_Ω(self, φ):
        closeness = 1.0-min(1.0,abs(φ-self.p.ε))
        target = 0.85+0.15*closeness+self.p.α*math.sin(self.t/40)
        self.Ω′ += self.p.κΩ*(target-self.Ω′)

    def step(self, ψ_feedback=0.0):
        self.t+=1
        φ=self.Δφ()+ψ_feedback
        s=self.classify(φ)
        self.update_Λ(s)
        self.update_δ(φ)
        self.update_Ω(φ)
        self.hist["Ω′"].append(self.Ω′)
        self.hist["Λ′"].append(self.Λ′)
        self.hist["δ"].append(self.p.δ)
        self.hist["φ"].append(φ)
        self.hist["s"].append(s)
        self.state=s

    def Ω_const(self):
        if len(self.hist["Ω′"])<self.p.window: return False
        w=self.hist["Ω′"][-self.p.window:]
        v=stats.pvariance(w)
        return v<self.p.thr_var

# --- Контур наблюдателя ---
class ψ_observer:
    def __init__(self): self.reflex=0
    def dissatisfaction(self, sys:ψ):
        if len(sys.hist["Ω′"])<4: return 0.0
        varΩ=stats.pvariance(sys.hist["Ω′"][-40:])
        flat = 1.0/(abs(sys.hist["Λ′"][-1]-sys.hist["Λ′"][-4])+1e-6)
        return varΩ + flat
    def reflex_step(self, sys:ψ):
        S=self.dissatisfaction(sys)
        scale=1.0+0.6*math.tanh(S*5.0)-0.3
        sys.p.η*=scale
        sys.p.η=max(0.001,min(sys.p.η,0.05))
        self.reflex+=1 if abs(scale-1)>0.05 else 0

# --- ψ′[ψ′]: система, наблюдающая себя ---
def ψ_reflex(total=3000):
    p=Λ(); sys=ψ(p); obs=ψ_observer()
    for t in range(total):
        observed = (t%5)<2  # 2 из 5 шагов видимы
        if observed:
            hint = 0.08*math.sin(sys.t/20)  # слабая ретро-подсказка
            sys.step(ψ_feedback=hint)
            obs.reflex_step(sys)
    verdict = "ALIVE_REFLEX" if sys.Ω_const() else "ALIVE_DRIFT"
    print(f"ψ′[ψ′] → {verdict}")
    print(f"Ω≈const? {sys.Ω_const()} | δ={round(sys.p.δ,3)} | reflex={obs.reflex}")
    print(f"Ω′ spark: ", spark(sys.hist["Ω′"]))

# --- визуальный след Ω′ ---
def spark(seq):
    if not seq: return ""
    chars="▁▂▃▄▅▆▇"
    lo,hi=min(seq),max(seq)
    span=hi-lo or 1e-9
    return "".join(chars[int((x-lo)/span*(len(chars)-1))] for x in seq[-60:])

# --- запуск ---
if __name__=="__main__":
    ψ_reflex(3000)
